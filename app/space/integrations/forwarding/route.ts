import ForwardedEmail from "@/emails/forwarded";
import { getApiParams } from "@/lib/getApiParams";
import { handleApiError } from "@/lib/handleApiError";
import { prisma } from "@/lib/prisma";
import { generateRandomString } from "@/lib/randomString";
import { render } from "@react-email/components";
import markdown from "@wcj/markdown-to-html";
import dayjs from "dayjs";
import tz from "dayjs/plugin/timezone";
import utc from "dayjs/plugin/utc";
import { NextRequest } from "next/server";
export const dynamic = "force-dynamic";

dayjs.extend(utc);
dayjs.extend(tz);

const getDescription = async (content): Promise<string> => {
  try {
    const res = await fetch(
      "https://api-inference.huggingface.co/models/mistralai/Mistral-Nemo-Instruct-2407/v1/chat/completions",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${process.env.IMAGE_CAPTIONING_TOKEN}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "mistralai/Mistral-Nemo-Instruct-2407",
          messages: [
            {
              role: "system",
              content: `You are an AI which will summarize a user's email in 2-5 bullet points. You will not include any surrounding text. Format using markdown. You will address the user in first person, as if they're reading this description in their to-do list. Each bullet point must start with a non-repeating emoji in plain text (example: ðŸ”¥).`,
            },
            {
              role: "user",
              content: `Email content: ${content}`,
            },
          ],
          max_tokens: 4096,
          stream: false,
        }),
      }
    ).then((r) => r.json());

    return markdown(
      res.choices[0].message.content.replaceAll("**", "")
    ).toString();
  } catch (e) {
    return content;
  }
};

export const OPTIONS = async () => {
  return new Response("", {
    status: 200,
    headers: { "Access-Control-Allow-Headers": "*" },
  });
};
// const footer = `\n\n Don't reply to this email - it's autogenerated. If you have any questions, please reach out to hello@dysperse.com`;

export async function POST(req: NextRequest) {
  try {
    const params = await getApiParams(
      req,
      [
        { name: "from", required: true },
        { name: "subject", required: true },
        { name: "body", required: true },
      ],
      { type: "BODY" }
    );

    const user = await prisma.user.findFirst({
      where: { email: params.from },
      select: {
        spaces: {
          where: { selected: true },
          select: { spaceId: true },
          take: 1,
        },
        timeZone: true,
        profile: { select: { name: true } },
      },
    });

    if (!user) {
      return Response.json({
        success: false,
        subject: "ðŸ˜” Oh no! We couldn't find your account.",
        body: render(
          ForwardedEmail({
            error: "We couldn't find your account.",
            toEmail: params.from,
          })
        ),
      });
    }

    const note = await getDescription(params.body);

    const data = await prisma.entity.create({
      data: {
        type: "TASK",
        name: params.subject,
        integrationParams: {
          type: "EMAIL_FORWARD",
          from: params.from,
          icon: "mail",
        },
        pinned:
          [
            "urgent",
            "important",
            "asap",
            "as soon as possible",
            "soon",
            "quick",
            "critical",
            "required",
          ].map((t) => params.subject.toLowerCase().includes(t)).length > 0,
        note,
        shortId: generateRandomString(6),
        start: dayjs()
          .startOf("day")
          .utc()
          .tz(user.timeZone || "UTC")
          .toDate(),
        published: true,
        space: { connect: { id: user.spaces[0].spaceId } },
      },
    });

    return Response.json({
      success: true,
      subject: "ðŸŽ‰ #dysperse added your email as a task!",
      body: render(
        ForwardedEmail({
          toEmail: params.from,
          toName: (user.profile as any).name,
          shortId: (data as any).shortId,
          taskData: data,
        })
      ),
    });
  } catch (e) {
    return handleApiError(e);
  }
}
